<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div style="display: flex; flex-direction: column; align-items: center;">
        <canvas id="scene3d" width="400" height="300" style="border: 1px solid #ccc;"></canvas>
        <div id="voiceStatus" style="margin-top: 10px; color: #666;">æŒ‰ä½ç©ºæ ¼é”®è¯´è¯</div>
    </div>

<script>
// 3Dåœºæ™¯ç›¸å…³å˜é‡
let scene, camera, renderer, quokkaModel;
let mixer; // æ·»åŠ åŠ¨ç”»æ··åˆå™¨å˜é‡

// è¯­éŸ³æ§åˆ¶ç›¸å…³å˜é‡
let recognition = null;
let isRecording = false;

// åˆå§‹åŒ–3Dåœºæ™¯
function init3DScene() {
    // åˆ›å»ºåœºæ™¯
    scene = new THREE.Scene();
    
    // åˆ›å»ºæ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('scene3d'),
        antialias: true
    });
    renderer.setSize(400, 300);
    renderer.setClearColor(0x87CEEB);  // è®¾ç½®å¤©ç©ºè“è‰²èƒŒæ™¯
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // æ·»åŠ æŸ”å’Œé˜´å½±
    
    // è°ƒæ•´ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);  // å¢åŠ ç¯å¢ƒå…‰å¼ºåº¦
    scene.add(ambientLight);
    
    // è°ƒæ•´å¹³è¡Œå…‰
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
    directionalLight.position.set(5, 15, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    scene.add(directionalLight);
    
    // æ·»åŠ è‰åœ°
    const textureLoader = new THREE.TextureLoader();
    const grassTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', 
        function(texture) {
            texture.encoding = THREE.sRGBEncoding;  // ä¿®æ­£çº¹ç†é¢œè‰²
        }
    );
    grassTexture.wrapS = THREE.RepeatWrapping;
    grassTexture.wrapT = THREE.RepeatWrapping;
    grassTexture.repeat.set(8, 8);
    
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        map: grassTexture,
        roughness: 0.6,  // é™ä½ç²—ç³™åº¦
        metalness: 0.0,  // é™ä½é‡‘å±åº¦
        color: 0xffffff  // æ·»åŠ ç™½è‰²åŸºç¡€è‰²
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // è°ƒæ•´ç›¸æœºä½ç½®
    camera = new THREE.PerspectiveCamera(75, 400/300, 0.1, 1000);
    camera.position.set(0, 12, 16);  // å¢åŠ ç›¸æœºé«˜åº¦å’Œè·ç¦»
    camera.lookAt(0, 0, 0);
    
    // åŠ è½½è¢‹é¼ æ¨¡å‹
    const loader = new THREE.GLTFLoader();
    
    // åˆ›å»ºä¸€ä¸ªPromiseæ•°ç»„æ¥åŠ è½½æ‰€æœ‰æ¨¡å‹
    const modelPromises = [
        'models/walking.glb',    // èµ°è·¯åŠ¨ç”»
        'models/confused.glb',   // å›°æƒ‘åŠ¨ç”»
        'models/dance.glb',      // èˆè¹ˆåŠ¨ç”»1
        'models/dance2.glb',     // èˆè¹ˆåŠ¨ç”»2
        'models/Happy_jump.glb', // å¼€å¿ƒè·³è·ƒ
        'models/happy.glb',      // å¼€å¿ƒåŠ¨ç”»
        'models/lazy.glb',       // æ‡’æ•£åŠ¨ç”»
        'models/stand.glb'       // ç«™ç«‹åŠ¨ç”»
    ].map(url => new Promise((resolve, reject) => {
        loader.load(url, resolve, undefined, reject);
    }));
    
    // ç­‰å¾…æ‰€æœ‰æ¨¡å‹åŠ è½½å®Œæˆ
    Promise.all(modelPromises).then(models => {
        const [walkingModel, confusedModel, danceModel, dance2Model, 
               jumpModel, happyModel, lazyModel, standModel] = models;
        
        // ä½¿ç”¨ç¬¬ä¸€ä¸ªæ¨¡å‹ï¼ˆwalkingï¼‰ä½œä¸ºä¸»æ¨¡å‹
        quokkaModel = walkingModel.scene;
        quokkaModel.scale.set(6, 6, 6);
        quokkaModel.position.y = 0;
        
        // è®¾ç½®é˜´å½±
        quokkaModel.traverse((node) => {
            if (node.isMesh) {
                node.castShadow = true;
            }
        });
        
        // è®¾ç½®åŠ¨ç”»æ··åˆå™¨
        mixer = new THREE.AnimationMixer(quokkaModel);
        
        // åˆ›å»ºåŠ¨ç”»åŠ¨ä½œ
        const walkAction = mixer.clipAction(walkingModel.animations[0]);
        const confusedAction = mixer.clipAction(confusedModel.animations[0]);
        const danceAction = mixer.clipAction(danceModel.animations[0]);
        const dance2Action = mixer.clipAction(dance2Model.animations[0]);
        const jumpAction = mixer.clipAction(jumpModel.animations[0]);
        const happyAction = mixer.clipAction(happyModel.animations[0]);
        const lazyAction = mixer.clipAction(lazyModel.animations[0]);
        const standAction = mixer.clipAction(standModel.animations[0]);
        
        // é…ç½®åŠ¨ç”»
        walkAction.setLoop(THREE.LoopRepeat);
        confusedAction.setLoop(THREE.LoopRepeat);
        danceAction.setLoop(THREE.LoopRepeat);
        dance2Action.setLoop(THREE.LoopRepeat);
        jumpAction.setLoop(THREE.LoopOnce);
        happyAction.setLoop(THREE.LoopRepeat);
        lazyAction.setLoop(THREE.LoopRepeat);
        standAction.setLoop(THREE.LoopRepeat);
        
        // å­˜å‚¨åŠ¨ç”»å¼•ç”¨
        quokkaModel.actions = {
            walk: walkAction,
            confused: confusedAction,
            dance: danceAction,
            dance2: dance2Action,
            jump: jumpAction,
            happy: happyAction,
            lazy: lazyAction,
            stand: standAction
        };
        
        // é»˜è®¤æ’­æ”¾ç«™ç«‹åŠ¨ç”»
        standAction.play();
        
        scene.add(quokkaModel);
    }).catch(error => {
        console.error('æ¨¡å‹åŠ è½½å‡ºé”™:', error);
    });
    
    // ä¿®æ”¹åŠ¨ç”»å¾ªç¯å‡½æ•°
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        
        // æ›´æ–°åŠ¨ç”»æ··åˆå™¨
        if (mixer) {
            const delta = clock.getDelta();
            mixer.update(delta);
        }
        
        // æ·»åŠ è½»å¾®çš„æ‘†åŠ¨æ•ˆæœ
        if (quokkaModel) {
            // ä½¿ç”¨æ­£å¼¦å‡½æ•°åˆ›å»ºå¹³æ»‘çš„æ‘†åŠ¨
            const time = clock.getElapsedTime();
            quokkaModel.rotation.y = Math.sin(time * 0.5) * 0.1;  // å·¦å³è½»å¾®æ‘†åŠ¨
            quokkaModel.position.y = Math.sin(time * 2) * 0.1;    // ä¸Šä¸‹è½»å¾®æµ®åŠ¨
        }
        
        renderer.render(scene, camera);
    }
    animate();
}

// æƒ…æ„Ÿåˆ¤æ–­æ¨¡å—
function checkMood(text) {
    // å¼€å¿ƒç›¸å…³çš„åŠ¨ç”»ï¼šdance, dance2, Happy_jump, happy
    if (/å¼€å¿ƒ|é«˜å…´|å¿«ä¹|å¥½ç©|æœ‰è¶£|æ£’|å¥½|å“ˆå“ˆ|å˜»å˜»|è·³èˆ|è·³èµ·æ¥|èˆè¹ˆ/.test(text)) {
        return 'happy';
    }
    
    // å›°æƒ‘ç›¸å…³çš„åŠ¨ç”»ï¼šconfused
    if (/å›°æƒ‘|ä¸æ‡‚|ä¸ºä»€ä¹ˆ|æ€ä¹ˆä¼š|å¥‡æ€ª|æä¸æ‡‚|ç–‘æƒ‘|è¿·æƒ‘/.test(text)) {
        return 'confused';
    }
    
    // æ‡’æ•£ç›¸å…³çš„åŠ¨ç”»ï¼šlazy
    if (/ç´¯äº†|å›°äº†|å¥½ç´¯|å¥½å›°|æ‡’|ä¸æƒ³åŠ¨|ä¼‘æ¯/.test(text)) {
        return 'lazy';
    }
    
    // ç«™ç«‹ç›¸å…³çš„åŠ¨ç”»ï¼šstand
    if (/ç«™|ç«‹|åœ|ç­‰|ä¸åŠ¨/.test(text)) {
        return 'stand';
    }
    
    // éš¾è¿‡ç›¸å…³ï¼šè§¦å‘confusedæˆ–lazyåŠ¨ç”»
    if (/éš¾è¿‡|ä¼¤å¿ƒ|ä¸å¼€å¿ƒ|ä¸é«˜å…´|ç³Ÿç³•|å|ä¸å¥½|å‘œå‘œ|å“­/.test(text)) {
        return 'sad';
    }
    
    // é»˜è®¤èµ°è·¯åŠ¨ç”»ï¼šwalking
    return 'normal';
}

// æ›´æ–°æƒ…æ„Ÿåé¦ˆå‡½æ•°
function updateMood(mood) {
    if (!quokkaModel || !quokkaModel.actions) return;
    
    const { walk, confused, dance, dance2, jump, happy, lazy, stand } = quokkaModel.actions;
    
    // æ·¡å‡ºæ‰€æœ‰åŠ¨ç”»
    Object.values(quokkaModel.actions).forEach(action => {
        action.fadeOut(0.5);
    });
    
    switch(mood) {
        case 'happy':
            // éšæœºé€‰æ‹©ä¸€ä¸ªå¼€å¿ƒçš„åŠ¨ç”»
            const happyActions = [dance, dance2, jump, happy];
            const randomAction = happyActions[Math.floor(Math.random() * happyActions.length)];
            randomAction.reset().fadeIn(0.3).play();
            
            setTimeout(() => {
                randomAction.fadeOut(0.3);
                stand.reset().fadeIn(0.3).play();
            }, 3000);
            break;
            
        case 'confused':
            confused.reset().fadeIn(0.3).play();
            setTimeout(() => {
                confused.fadeOut(0.3);
                stand.reset().fadeIn(0.3).play();
            }, 3000);
            break;
            
        case 'lazy':
            lazy.reset().fadeIn(0.3).play();
            setTimeout(() => {
                lazy.fadeOut(0.3);
                stand.reset().fadeIn(0.3).play();
            }, 4000);
            break;
            
        case 'stand':
            stand.reset().fadeIn(0.3).play();
            break;
            
        case 'sad':
            // æ’­æ”¾å›°æƒ‘æˆ–æ‡’æ•£åŠ¨ç”»
            const sadAction = Math.random() > 0.5 ? lazy : confused;
            sadAction.reset().fadeIn(0.3).play();
            
            setTimeout(() => {
                sadAction.fadeOut(0.3);
                stand.reset().fadeIn(0.3).play();
            }, 3000);
            break;
            
        default:
            stand.reset().fadeIn(0.3).play();
    }
}

// åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«
function initSpeechRecognition() {
    const recognition = new webkitSpeechRecognition();
    recognition.lang = 'zh-CN';
    recognition.continuous = false;
    recognition.interimResults = false;
    
    recognition.onstart = () => {
        document.getElementById('voiceStatus').textContent = 'æ­£åœ¨å½•éŸ³...';
        document.getElementById('voiceStatus').style.color = '#ff4444';
    };
    
    recognition.onresult = (e) => {
        const text = e.results[0][0].transcript;
        document.getElementById('voiceStatus').textContent = `è¯†åˆ«ç»“æœ: ${text}`;
        const mood = checkMood(text);
        
        // æ›´æ–°3Dæ¨¡å‹åŠ¨ç”»
        updateMood(mood);
        
        // 2Dè¡¨æƒ…åé¦ˆ
        const quokkaEmoji = document.getElementById('quokka');
        quokkaEmoji.style.transition = 'all 0.5s';
        if(mood === 'happy') {
            quokkaEmoji.style.transform = 'translateY(-20px)';
            quokkaEmoji.textContent = 'ğŸ¨â†‘';
        } else if(mood === 'sad') {
            quokkaEmoji.style.transform = 'scale(0.8)';
            quokkaEmoji.textContent = 'ğŸ¨â†“';
        }
    };
    
    recognition.onend = () => {
        if (isRecording) {
            recognition.start();
        } else {
            document.getElementById('voiceStatus').textContent = 'æŒ‰ä½ç©ºæ ¼é”®è¯´è¯';
            document.getElementById('voiceStatus').style.color = '#666';
        }
    };
    
    recognition.onerror = (event) => {
        document.getElementById('voiceStatus').textContent = 'è¯­éŸ³è¯†åˆ«é”™è¯¯ï¼Œè¯·é‡è¯•';
        document.getElementById('voiceStatus').style.color = '#ff4444';
        isRecording = false;
    };
    
    return recognition;
}

// å¼€å§‹å½•éŸ³
function startRecording() {
    if (!recognition) {
        recognition = initSpeechRecognition();
    }
    isRecording = true;
    recognition.start();
}

// åœæ­¢å½•éŸ³
function stopRecording() {
    if (recognition && isRecording) {
        isRecording = false;
        recognition.stop();
    }
}

// æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬
document.addEventListener('keydown', (event) => {
    if (event.code === 'Space' && !isRecording && !event.repeat) {
        event.preventDefault();  // é˜²æ­¢é¡µé¢æ»šåŠ¨
        startRecording();
    }
});

document.addEventListener('keyup', (event) => {
    if (event.code === 'Space' && isRecording) {
        event.preventDefault();
        stopRecording();
    }
});

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–3Dåœºæ™¯
window.onload = init3DScene;
</script>
</body>
</html>